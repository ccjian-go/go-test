# 


#### 参考
    https://www.cnblogs.com/jonins/p/9956752.html   算法复杂度分析（下）：最好、最坏、平均、均摊等时间复杂度概述
    https://www.cnblogs.com/sxkgeek/p/9162477.html  算法的时间、空间复杂度详解
    https://www.cnblogs.com/sxkgeek/p/9159902.html  排序算法实现以及性能分析
   
#### Base
    概率论
   
#### Question
    确定平均算法复杂度
    
#### 大O表示法
    省略系数、低阶、常量
    系数：(*/)的数
    低阶：
    常量：(+-)的数
    
#### 常见算法复杂度
    常数阶O(1)，对数阶O(log2n)，线性阶O(n)，线性对数阶O(nlog2n)，
    平方阶O(n2)，立方阶O(n3)，k次方阶O(nk)，指数阶O(2n)

#### 细化时间复杂度场景
    多数情况下，我们不需要区分最好、最坏、平均情况时间复杂度。
    只有同一块代码在不同情况下时间复杂度有量级差距，我们才会区分3种情况，为的是更有效的描述代码的时间复杂度。

#### 细化时间复杂度分析
    最好情况时间复杂度（best case time complexity）。
        最好情况时间复杂度，表示在最理想的情况下，执行这段代码的时间复杂度。
    最坏情况时间复杂度（worst case time complexity）。
        最坏情况时间复杂度，表示在最糟糕的情况下，执行这段代码的时间复杂度。
    平均情况时间复杂度（average case time complexity）。
        我们将所有情况下代码执行的次数累加起来（（1+2+3....+n）+n），然后再除以所有情况数量（n+1），就可以得到需要遍历次数的平均值。
    均摊时间复杂度（amortized time complexity）。

#### 均摊时间复杂度
    分析方式：每一次O(n)都会跟着n次O(1)，所以把耗时多的复杂度均摊到耗时低的复杂度。得到的均摊时间复杂度为O(1)。
    对应的分析方式称为：摊还分析或平摊分析。
    通过摊还分析法得到的时间复杂度为均摊时间复杂度。

    应用场景：均摊时间复杂度和摊还分析应用场景较为特殊，对一个数据进行连续操作，大部分情况下时间复杂度都很低，
        只有个别情况下时间复杂度较高。而这组操作其存在前后连贯的时序关系。
        
#### 时间复杂度、空间复杂度、算法稳定性、算法复杂度
    时间复杂度定义：执行这个算法需要消耗多少时间，即算法计算执行的基本操作次数
    空间复杂度定义：这个算法需要消耗多少空间，即算法在运行过程中临时占用存储空间大小的度量，
        强调的是辅助空间的大小（对数据进行操作的工作单元和存储一些计算的辅助单元），而不是指所有数据所占用的空间
    算法稳定性定义：稳定性是指如果存在多个具有相同排序码的记录，经过排序后，这些记录的相对次序仍然保持不变，
        则这种排序算法称为稳定的（简单的说，要排序的数中有两个相同的数，用A算法进行排序后，两个相等数的位置不会互换，则A算法是稳定的）

    不稳定的：快速排序、希尔排序、选择排序、堆排序（快些选一堆）


#### 算法步骤-排序-位置交换
    冒泡排序
        比较相邻的元素。如果第一个比第二个大，就交换它们两个；
        对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
        针对所有的元素重复以上的步骤，除了最后一个；
        重复步骤1~3，直到排序完成。 注意：比较完一遍之后下次比较会少一次，因为最后一个数一定是最大的，所以不必要管最后一个数了
            此时时间复杂度平均情况是 O(n)，最坏情况是也是 O(n)，空间复杂度是O(1)，算法稳定性为稳定
    冒泡排序-优化
        增加flag参数，用于表示一轮操作下来是否有发生需要排序的情况，若不需要发生位置交换，则已排好序。用flag告知并退出循环
            此时时间复杂度最好的情况下是 O(1)
        
    快速排序
        把整个序列看做一个数组，把第零个位置看做中轴，和最后一个比，如果比它小交换，比它大不做任何处理；交换了以后再和小的那端比，比它小不交换，比他大交换。
        这样循环往复，一趟排序完成，左边就是比中轴小的，右边就是比中轴大的，然后再用分治法，分别对这两个独立的数组进行排序。
            最好情况 O(2log2n)  最坏情况 O(n)  平均情况 O(2log2n)
































